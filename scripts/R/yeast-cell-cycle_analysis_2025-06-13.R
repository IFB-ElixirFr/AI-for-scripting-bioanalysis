#### Analysis of the yeast cell cycle transcriptome ####
##
## This script was generated by iterative prompting with ChatGPT 4.0
## as a demo for the workshop "Using generative AI to implement scripts for bioanalysis"
## organised in Paris on June 13, 2025. 
##
## All the code below is exactly as produced by ChatGPT, except for a single line that 
## was edited manually by the teacher (Jacques van Helden), commented below. 

# Load necessary libraries
if (!requireNamespace("fs", quietly = TRUE)) install.packages("fs")
library(fs)
if (!requireNamespace("readr", quietly = TRUE)) install.packages("readr")
library(readr)

# Check if 'pheatmap' is installed; install if not, then load
if (!requireNamespace("pheatmap", quietly = TRUE)) {
  install.packages("pheatmap")
}
library(pheatmap)

# ---- Parameters ----
DATA_URL <- "https://ifb-elixirfr.github.io/AI-for-scripting-bioanalysis/data/yeast-transcriptome-cell-cycle/oscillating-genes_normalized-profiles.tsv"
HOME_DIR <- path_home()
ANALYSIS_DIR <- path(HOME_DIR, "yeast-cell-cycle-analysis")
FILENAME <- "oscillating-genes_normalized-profiles.tsv"
FILE_PATH <- path(ANALYSIS_DIR, FILENAME)

# ---- Functions ----

#' Download and check yeast cell cycle dataset
#'
#' This function creates a target directory in the user's home folder,
#' downloads a tab-separated file from a public URL, and checks its presence and size.
#'
#' @param url The URL of the dataset to download.
#' @param target_dir The directory where the file should be saved.
#' @param filename The name to save the downloaded file as.
#' @return The path of the downloaded file if successful, otherwise throws an error.
#' @export
download_and_check_dataset <- function(url, target_dir, filename) {
  # Create the target directory if it doesn't exist
  if (!dir_exists(target_dir)) {
    dir_create(target_dir)
  }
  
  # Define the full path for the output file
  file_path <- path(target_dir, filename)
  
  # Download the file (overwrite = TRUE ensures re-download if needed)
  download.file(url, destfile = file_path, mode = "wb")
  
  # Check if the file exists and is not empty
  if (!file_exists(file_path)) {
    stop("File was not downloaded.")
  }
  if (file_info(file_path)$size == 0) {
    stop("Downloaded file is empty.")
  }
  
  return(file_path)
}

#' Unit test for dataset download function
#'
#' Tests that the file was correctly downloaded and is not empty.
#' Prints success message if test passes, otherwise stops.
#'
#' @return NULL (invisible), throws error if test fails
#' @export
test_download_and_check_dataset <- function() {
  cat("Running test for download_and_check_dataset...\n")
  file_path <- download_and_check_dataset(DATA_URL, ANALYSIS_DIR, FILENAME)
  
  if (!file_exists(file_path)) {
    stop("Test failed: File does not exist.")
  }
  if (file_info(file_path)$size == 0) {
    stop("Test failed: File is empty.")
  }
  
  cat("✅ Test passed: File downloaded and is not empty.\n")
  invisible(NULL)
}


#' Load the dataset from file
#'
#' Loads a tab-separated values (TSV) file into a data frame.
#'
#' @param file_path The full path to the TSV file.
#'
#' @return A data frame containing the dataset.
#' @export
load_dataset <- function(file_path) {
  # read_tsv automatically handles headers and parses columns
  #   df <- read_tsv(file_path, col_types = cols())

  # The following line was manually implemented by Jacques van Helden, 
  # because the initial code was not working, read_tsv was merging the 
  # two last columsns into a single one. After several unsuccessful attempts 
  # to get a fix from ChatGPT,I rewrote the line maually with read.csv
  df <- read.csv(file_path, header=TRUE, row.names=1, sep="\t")
  return(df)
}


#' Unit test for dataset loading
#'
#' Loads the dataset and checks that it contains exactly 50 data columns
#' (excluding any annotation columns, if applicable).
#'
#' @param df The data frame loaded from the dataset.
#' @return NULL (invisible), throws error if test fails.
#' @export
test_dataset_dimensions <- function(df) {
  cat("Running test for dataset dimensions...\n")
  
  n_cols <- ncol(df)
  
  if (n_cols != 50) {
    stop(paste("Test failed: Expected 50 columns, got", n_cols))
  }
  
  cat("✅ Test passed: Dataset contains 50 columns.\n")
  invisible(NULL)
}

#' Normalize gene expression data
#'
#' Applies a two-step normalization procedure to a data frame of gene expression values:
#' 1. Log2 transformation with pseudocount: y = log2(x + 1)
#' 2. Row-wise standardization: z = (y - mean(y)) / sd(y)
#'
#' @param df A numeric data frame where rows represent genes and columns represent samples.
#'           Row names must be gene identifiers.
#'
#' @return A data frame of the same shape with normalized expression values.
#' @export
normalize_expression_data <- function(df) {
  if (!is.data.frame(df)) stop("Input must be a data frame.")
  
  # Step 1: log2(x + 1) transformation
  log_transformed <- log2(df + 1)
  
  # Step 2: row-wise standardization
  row_standardized <- t(apply(log_transformed, 1, function(row) {
    m <- mean(row, na.rm = TRUE)
    s <- sd(row, na.rm = TRUE)
    if (s == 0) {
      rep(0, length(row))  # avoid division by zero: return zeros if sd == 0
    } else {
      (row - m) / s
    }
  }))
  
  # Convert matrix back to data frame and preserve row and column names
  result_df <- as.data.frame(row_standardized)
  rownames(result_df) <- rownames(df)
  colnames(result_df) <- colnames(df)
  
  return(result_df)
}

#' Unit test for normalized expression data
#'
#' Verifies that each row of the normalized data has approximately zero mean
#' and unit standard deviation (within a given tolerance).
#'
#' @param norm_df A data frame returned by `normalize_expression_data()`.
#' @param epsilon A numeric tolerance for floating-point comparisons (default = 1e-12).
#' @return NULL (invisible), throws an error if test fails.
#' @export
test_normalized_data <- function(norm_df, epsilon = 1e-12) {
  cat("Running test for normalized expression data...\n")
  
  # Compute row means and standard deviations
  row_means <- rowMeans(norm_df, na.rm = TRUE)
  row_sds   <- apply(norm_df, 1, sd, na.rm = TRUE)
  
  # Check if all means are approximately 0
  if (any(abs(row_means) > epsilon)) {
    failed_rows <- sum(abs(row_means) > epsilon)
    stop(paste("Test failed:", failed_rows, "row means differ from 0 by more than", epsilon))
  }
  
  # Check if all standard deviations are approximately 1
  if (any(abs(row_sds - 1) > epsilon)) {
    failed_rows <- sum(abs(row_sds - 1) > epsilon)
    stop(paste("Test failed:", failed_rows, "row standard deviations differ from 1 by more than", epsilon))
  }
  
  cat("✅ Test passed: all rows have mean ~ 0 and sd ~ 1 (±", epsilon, ").\n")
  invisible(NULL)
}

#' Plot a heatmap of gene expression data
#'
#' Produces a heatmap from a data frame, with genes in rows and samples/time points in columns.
#' Uses a color scale from cyan (low values) to yellow (high values).
#'
#' @param df A numeric data frame with genes as rows and samples as columns.
#' @param title A title for the heatmap (optional).
#'
#' @return None. The function plots a heatmap.
#' @export
plot_expression_heatmap <- function(df, title = "Expression Heatmap") {
  if (!requireNamespace("pheatmap", quietly = TRUE)) {
    stop("Package 'pheatmap' is required. Please install it with install.packages('pheatmap').")
  }
  
  # Custom color scale from cyan to yellow
  color_scale <- colorRampPalette(c("cyan", "black", "yellow"))(100)
  
  # Draw heatmap
  pheatmap::pheatmap(
    mat = as.matrix(df),
    color = color_scale,
    cluster_rows = TRUE,
    cluster_cols = TRUE,
    show_rownames = FALSE,
    show_colnames = TRUE,
    fontsize_col = 10,
    main = title,
    border_color = NA
  )
}

#' Plot a heatmap of gene expression data (with fixed row/column order)
#'
#' Produces a heatmap from a data frame, with genes in rows and samples/time points in columns.
#' Preserves the order of rows and columns as they appear in the data frame.
#' Uses a color scale from cyan (low values) to yellow (high values).
#'
#' @param df A numeric data frame with genes as rows and samples as columns.
#' @param title A title for the heatmap (optional).
#'
#' @return None. The function plots a heatmap.
#' @export
plot_expression_heatmap <- function(df, title = "Expression Heatmap") {
  # Ensure the 'pheatmap' package is installed and loaded
  if (!requireNamespace("pheatmap", quietly = TRUE)) {
    install.packages("pheatmap")
  }
  library(pheatmap)
  
  # Color scale from cyan (low) → black → yellow (high)
  color_scale <- colorRampPalette(c("cyan", "black", "yellow"))(100)
  
  # Plot the heatmap without clustering
  pheatmap::pheatmap(
    mat = as.matrix(df),
    color = color_scale,
    cluster_rows = FALSE,
    cluster_cols = FALSE,
    show_rownames = FALSE,
    show_colnames = TRUE,
    fontsize_col = 10,
    main = title,
    border_color = NA
  )
}

#' Order genes by decreasing expression in a given column
#'
#' @param df A data frame with genes in rows and samples/time points in columns.
#' @param col_index Column to use for sorting (default = 1)
#'
#' @return A reordered data frame
#' @export
order_genes_by_column <- function(df, col_index = 1) {
  df[order(-df[[col_index]]), ]
}

#' Order genes by their projection on the first principal component (PCA)
#'
#' @param df A data frame with genes in rows and samples in columns.
#'
#' @return A reordered data frame
#' @export
order_genes_by_pca <- function(df) {
  pca <- prcomp(df, center = TRUE, scale. = TRUE)
  pc1_scores <- pca$x[, 1]  # projections of each gene on PC1
  df[order(pc1_scores), ]
}



#' Order genes by the phase of the dominant frequency component (FFT)
#'
#' Assumes that the expression pattern follows a periodic signal.
#' Rows (genes) are sorted by the phase of the strongest non-zero frequency.
#'
#' @param df A data frame with genes in rows and samples in columns.
#'
#' @return A reordered data frame
#' @export
order_genes_by_fft_phase <- function(df) {
  get_phase <- function(row) {
    fft_result <- fft(row)
    # Ignore DC component (index 1), get dominant frequency component
    magnitudes <- Mod(fft_result)[2:floor(length(fft_result)/2)]
    phases <- Arg(fft_result)[2:floor(length(fft_result)/2)]
    dominant_idx <- which.max(magnitudes)
    phases[dominant_idx]
  }
  
  phases <- apply(df, 1, get_phase)
  df[order(phases), ]
}

#' Order genes by the time point (column index) of their maximum expression
#'
#' This function finds the column (time point) where each gene reaches
#' its maximum expression, and orders genes accordingly.
#'
#' @param df A numeric data frame (genes in rows, time points in columns)
#'
#' @return A reordered data frame, sorted by column index of maximum expression
#' @export
order_genes_by_max_column <- function(df) {
  # For each gene (row), find the column index of its maximum value
  max_columns <- apply(df, 1, which.max)
  
  # Order the rows (genes) by increasing column index of max expression
  df[order(max_columns), ]
}



#' Plot and export a heatmap with red-white-blue color scale
#'
#' @param df A numeric data frame (genes × time points)
#' @param filename Output PNG filename
#' @param title Optional title for the plot
#' @param pixel_per_gene Vertical resolution (default = 1 pixel/gene)
#' @param pixel_per_timepoint Horizontal resolution (default = 30 pixels/column)
#'
#' @return None. A PNG file is created
#' @export
plot_expression_heatmap_to_png <- function(df, filename, title = NULL,
                                           pixel_per_gene = 1,
                                           pixel_per_timepoint = 50) {
  # Load pheatmap if not yet loaded
  if (!requireNamespace("pheatmap", quietly = TRUE)) {
    install.packages("pheatmap")
  }
  library(pheatmap)
  
  # Create red-white-blue color scale centered on 0
  max_val <- max(df, na.rm = TRUE)
  min_val <- min(df, na.rm = TRUE)
  abs_max <- max(abs(min_val), abs(max_val))  # symmetric scale
  breaks <- seq(-abs_max, abs_max, length.out = 101)
  color_scale <- colorRampPalette(c("blue", "white", "red"))(100)
  
  # Compute dimensions
  n_genes <- nrow(df)
  n_timepoints <- ncol(df)
  height_px <- max(800, n_genes * pixel_per_gene)
  width_px <- max(800, n_timepoints * pixel_per_timepoint)
  
  # Export heatmap as PNG
  png(filename, width = width_px, height = height_px, res = 150)
  
  pheatmap::pheatmap(
    mat = as.matrix(df),
    color = color_scale,
    breaks = breaks,
    cluster_rows = FALSE,
    cluster_cols = FALSE,
    show_rownames = FALSE,
    show_colnames = TRUE,
    fontsize_col = 10,
    main = title,
    border_color = NA
  )
  
  dev.off()
}



#### Run the analysis ####

# ---- Step 1: Download the dataset and store it in a local folder ----
test_download_and_check_dataset()

# ---- Step 2: Load the data table and check its dimensions ----
df <- load_dataset(FILE_PATH)
test_dataset_dimensions(df)

# ---- Step 3: Normalise the count table ----

normalized_df <- normalize_expression_data(df)
test_normalized_data(normalized_df)

# ---- Step 4: Heatmaps ----

# Heatmap before normalization
plot_expression_heatmap(df, title = "Raw Expression Data")

# Heatmap after normalization
plot_expression_heatmap(normalized_df, title = "Normalized Expression Data")

# Order genes by different methods
df_col_sorted_1 <- order_genes_by_column(normalized_df, col_index = 1)
# JvH added this line to tes the effect of gene ordering on the second column
df_col_sorted_2 <- order_genes_by_column(normalized_df, col_index = 2)
df_pca_sorted <- order_genes_by_pca(normalized_df)
df_fft_sorted <- order_genes_by_fft_phase(normalized_df)

# Apply the ordering
df_sorted_maxcol <- order_genes_by_max_column(normalized_df)


# Plot heatmaps
plot_expression_heatmap(df_col_sorted_1, title = "Sorted by Expression (1st Column)")
# JvH added this line to tes the effect of gene ordering on the second column
plot_expression_heatmap(df_col_sorted_2, title = "Sorted by Expression (2nd Column)")
plot_expression_heatmap(df_pca_sorted, title = "Sorted by PCA Component 1")
plot_expression_heatmap(df_fft_sorted, title = "Sorted by FFT Phase")

# Save heatmaps to PNG with 1 pixel per gene
plot_expression_heatmap_to_png(df_col_sorted_1, "heatmap_sorted_by_column_1.png",
                               title = "Sorted by Expression (1st Column)")

# JvH added this line to tes the effect of gene ordering on the second column
plot_expression_heatmap_to_png(df_col_sorted_2, "heatmap_sorted_by_column_2.png",
                               title = "Sorted by Expression (2nd Column)")

plot_expression_heatmap_to_png(df_pca_sorted, "heatmap_sorted_by_pca.png",
                               title = "Sorted by PCA Component 1")

plot_expression_heatmap_to_png(df_fft_sorted, "heatmap_sorted_by_fft.png",
                               title = "Sorted by FFT Phase")

# Plot the heatmap
plot_expression_heatmap_to_png(
  df_sorted_maxcol,
  filename = "heatmap_sorted_by_max_column.png",
  title = "Sorted by Column of Maximum Expression"
)



# ---- End of analysis ----
